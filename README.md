# ECE550

# Checkpoint 1
 Author: Dongyu Lan
 Date: 09/21/2023
 Netid id: dl393
 Course: ECE 550, Duke University, Durham, NC

## Duke Community Standard, Affirmation
I understand that each `git` commit I create in this repository is a submission. I affirm that each submission complies with the Duke Community Standard and the guidelines set forth for this assignment. I further acknowledge that any content not included in this commit under the version control system cannot be considered as a part of my submission. Finally, I understand that a submission is considered submitted when it has been pushed to the server.m

### Design Description
I designed and simulated an ALU using Verilog. It is a non-RCA adder with support for addition & subtraction.
My ALU runs two operations(add, sub) for the inputs data_operandA, data_operandB. 

**Module FA (Full Adder)**
<br>Full Adder is a fundamental digital circuit used in binary addition. It takes three inputs, a, b, and cin, and produces two outputs: sum and cout. The FA module calculates the sum of a, b, and cin.

**Module RCA**
<br>The RCA constructed using 16 Full Adders is a combinational circuit designed to perform binary addition of two 16-bit numbers.It takes three inputs, a, b, and cin, and produces three outputs: sum, cout and w. A and b are two 16-bit operands and an initial carry input (cin) are provided by 32bit-CSA. The w output, represents the cin for the most significant bit Full Adder in the 16-bit RCA.

**Module CSA**
<br>The 32-bit CSA is a digital circuit designed to efficiently perform binary addition of two 32-bit numbers. The 32-bit CSA is divided into two major parts: Low 16-bit RCA and two High 16-bit RCA. These two RCAs are used to calculate the sum and carry-out for the high bits of the result. The selection of which high-bit RCA to use is determined by the cout generated by the Low 16-bit RCA. If the carry-out from the Low 16-bit RCA is 0, the first High 16-bit RCA is selected; otherwise, the second High 16-bit RCA is chosen.

**Overflow**
<br>Overflow is determined based on whether the cout of the most significant bit and the second most significant bit of the 32-bit CSA.If they are equal, overflow is set to 0; if they are not equal, overflow is set to 1.

**alu**
<br>The alu is a core module. It can handle addition and subtraction based on an operation code.if the least significant bit is 0, it signifies addition. If the least significant bit is 1, it indicates subtraction. Within the ALU module, there is also a call to the reverse module, which reverses each bit of data_operandB. Finally, the CSA (Carry Select Adder) is called to compute the sum of data_operandB and realB.

**Reverse**
<br>The reverse module reverses each bit of a binary number.

